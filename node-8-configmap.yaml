apiVersion: v1
kind: ConfigMap
metadata:
  name: node-8-configmap
  namespace: astrid-kube
data:
  logstash.yml: |
        config.reload:
            automatic: true
            interval: 5s
        http.host: "0.0.0.0"
  pipelines.yml: |
          - pipeline.id: bau
            path.config: "/usr/share/logstash/pipeline/polycube_bau.conf"
          - pipeline.id: bau_and_warn
            path.config: "/usr/share/logstash/pipeline/polycube_bau_and_warn.conf"
          - pipeline.id: dns_bau
            path.config: "/usr/share/logstash/pipeline/polycube_dns_bau.conf"
          - pipeline.id: dns_warn
            path.config: "/usr/share/logstash/pipeline/polycube_dns_warn.conf"
  polycube_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30001
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node9:Turin RrC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_bau_and_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30002
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node9:Turin RrC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "ntp_mode_private_packets_total"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }
  polycube_dns_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30003
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node9:Turin RrC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_dns_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30004
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node9:Turin RrC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "Total DNS queries of type ANY"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }

  scheduler.sh : |
   #!/bin/sh
   set -e
   
   polling=$POLLING_TIME
   polling_time_file=/usr/share/scheduler/pollingtime.txt
   previous_stat=0
   ntp_bau_port=30001
   ntp_bau_and_warn_port=30002
   dns_bau_port=30003
   dns_bau_and_warn_port=30004
   
   read_and_send() {
     response_dynmon=$(curl -s 'http://localhost:9000/polycube/v1/dynmon' --max-time 2)
   
     for cube in $( echo $response_dynmon | jq '.[] | select( type=="object" ) | .name ' -r )
     do
             metrics=$(curl -s "http://localhost:9000/polycube/v1/dynmon/${cube}/metrics" --max-time 2 )
             map_counter=0
             map_type=""
             for map in $( echo $metrics | jq '."ingress-metrics"[].name ' | sed "s/\ /-/g" )
             do
                     map_counter=$(( $map_counter + 1 ))
                     if echo $map | grep -iqF "dns";then
                             map_type="DNS"
                     fi
                     if echo $map | grep -iqF "ntp";then
                             map_type="NTP"
                     fi
             done
   
             port=0
   
             if [[ $map_type == "NTP" ]]; then
                     if [[ $map_counter == 1 ]]; then
                             port=$ntp_bau_port
                     fi
                     if [[ $map_counter == 2 ]]; then
                             port=$ntp_bau_and_warn_port
                     fi
             fi
   
             if [[ $map_type == "DNS" ]]; then
                     if [[ $map_counter == 1 ]]; then
                             port=$dns_bau_port
                     fi
                     if [[ $map_counter ==  2 ]]; then
                             port=$dns_bau_and_warn_port
                     fi
             fi
   
             echo $map_type"-"$map_counter" - response: "$metrics
   
             if [[ $port != 0 ]]; then
                     curl -H "content-type: application/json" -XPUT -s "http://127.0.0.1:${port}" -d "${metrics}"
             fi
     done
   
     return
   }
   
   while true
   do
     if [ -f "$polling_time_file" ];
     then
       actual_stat=`stat $polling_time_file -c %Y`
       if [ $actual_stat -ne $previous_stat ];
       then
         polling=`cat $polling_time_file`
         previous_stat=$actual_stat
       fi
     else
       echo "$polling" > $polling_time_file
     fi
   
   
     read_and_send &
     echo "wait for "$polling" second..."
     sleep $polling
   done
